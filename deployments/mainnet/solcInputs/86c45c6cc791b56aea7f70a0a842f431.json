{
  "language": "Solidity",
  "sources": {
    "contracts/ichiPowah.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"./lib/AddressSet.sol\";\nimport \"./interfaces/ISatellite.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ICHIPowah is Ownable {\n\n    using SafeMath for uint;\n    using AddressSet for AddressSet.Set;\n\n    uint public constant PRECISION = 100;\n\n    bytes32 constant NULL_DATA = \"\";\n\n    // a Constituency contains balance information that can be interpreted by an interpreter\n    struct Constituency {\n        address interpreter;\n        uint16 weight; // 100 = 100%\n        bytes32 params;\n    }\n    // constituency address => details\n    mapping(address => Constituency) public constituencies; \n    // interable key set with delete\n    AddressSet.Set constituencySet;\n\n    event NewConstituency(address instance, address interpreter, uint16 weight, bytes32 params);\n    event UpdateConstituency(address instance, address interpreter, uint16 weight, bytes32 params);\n    event DeleteConstituency(address instance);\n\n    /**\n     * @notice user voting power reported through a normal ERC20 function \n     * @param user the user to inspect\n     * @param powah user's voting power\n     */    \n    function balanceOf(address user) public view returns(uint powah) {\n        uint count = constituencySet.count();\n        for(uint i=0; i<count; i++) {\n            address instance = constituencySet.keyAtIndex(i);\n            Constituency storage c = constituencies[instance];\n            powah = powah.add(ISatellite(c.interpreter).getPowah(instance, user, c.params).mul(c.weight).div(PRECISION));\n        }\n    }\n\n    /**\n     * @notice adjusted total supply factor (for computing quorum) is the weight-adjusted sum of all possible votes\n     * @param supply the total number of votes possible given circulating supply and weighting\n     */\n    function totalSupply() public view returns(uint supply) {\n        uint count = constituencySet.count();\n        for(uint i=0; i<count; i++) {\n            address instance = constituencySet.keyAtIndex(i);\n            Constituency storage c = constituencies[instance];\n            supply = supply.add(ISatellite(c.interpreter).getSupply(instance).mul(c.weight).div(PRECISION));\n        }\n    }\n\n    /*********************************\n     * Discoverable Internal Structure\n     *********************************/\n\n    /**\n     * @notice count configured constituencies\n     * @param count number of constituencies configured\n     */\n    function constituencyCount() public view returns(uint count) {\n        count = constituencySet.count();\n    }\n\n    /**\n     * @notice enumerate the configured constituencies\n     * @param index row number to inspect\n     * @param constituency address of the contract where tokens are staked\n     */\n    function constituencyAtIndex(uint index) public view returns(address constituency) {\n        constituency = constituencySet.keyAtIndex(index);\n    }\n\n    /*********************************\n     * CRUD\n     *********************************/\n\n    /**\n     * @notice insert a new constituency to start counting as voting power\n     * @param constituency address of the contract to inspect\n     * @param interpreter address of the satellite that can interact with the type of contract at constituency address \n     * @param weight scaling adjustment to increase/decrease voting power. 100 = 100% is correct in most cases\n     */\n    function insertConstituency(address constituency, address interpreter, uint16 weight, bytes32 params) external onlyOwner {\n        constituencySet.insert(constituency, \"ICHIPowah: constituency is already registered.\");\n        Constituency storage c = constituencies[constituency];\n        c.interpreter = interpreter;\n        c.weight = weight;\n        c.params = params;\n        emit NewConstituency(constituency, interpreter, weight, params);\n    }\n\n    /**\n     * @notice delete a constituency to stop counting as voting power\n     * @param constituency address of the contract to stop inspecting\n     */\n    function deleteConstituency(address constituency) external onlyOwner {\n        constituencySet.remove(constituency, \"ICHIPowah: unknown instance\");\n        delete constituencies[constituency];\n        emit DeleteConstituency(constituency);\n    }\n\n    /**\n     * @notice update a constituency by overwriting all values (safe to remove and use 2-step delete, re-add)\n     * @param constituency address of the contract to inspect\n     * @param interpreter address of the satellite that can interact with the type of contract at constituency address \n     * @param weight scaling adjustment to increase/decrease voting power. 100 = 100% is correct in most cases\n     */\n    function updateConstituency(address constituency, address interpreter, uint16 weight, bytes32 params) external onlyOwner {\n        require(constituencySet.exists(constituency), \"ICHIPowah unknown constituency\");\n        Constituency storage c = constituencies[constituency];\n        c.interpreter = interpreter;\n        c.weight = weight;\n        c.params = params;\n        emit UpdateConstituency(constituency, interpreter, weight, params);\n    }\n\n}"
    },
    "contracts/lib/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random access\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced. \n * @dev Sets are unordered. Delete operations reorder keys. All operations have a \n * fixed gas cost at any scale, O(1). \n */\n\nlibrary AddressSet {\n    \n    struct Set {\n        mapping(address => uint) keyPointers;\n        address[] keyList;\n    }\n\n    /**\n     @notice insert a key. \n     @dev duplicate keys are not permitted.\n     @param self storage pointer to a Set. \n     @param key value to insert.\n     */    \n    function insert(Set storage self, address key, string memory errorMessage) internal {\n        require(!exists(self, key), errorMessage);\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length-1;\n    }\n\n    /**\n     @notice remove a key.\n     @dev key to remove must exist. \n     @param self storage pointer to a Set.\n     @param key value to remove.\n     */    \n    function remove(Set storage self, address key, string memory errorMessage) internal {\n        require(exists(self, key), errorMessage);\n        uint last = count(self) - 1;\n        uint rowToReplace = self.keyPointers[key];\n        address keyToMove = self.keyList[last];\n        self.keyPointers[keyToMove] = rowToReplace;\n        self.keyList[rowToReplace] = keyToMove;\n        delete self.keyPointers[key];\n        self.keyList.pop();\n    }\n\n    /**\n     @notice count the keys.\n     @param self storage pointer to a Set. \n     */       \n    function count(Set storage self) internal view returns(uint) {\n        return(self.keyList.length);\n    }\n\n    /**\n     @notice check if a key is in the Set.\n     @param self storage pointer to a Set.\n     @param key value to check. Version\n     @return bool true: Set member, false: not a Set member.\n     */  \n    function exists(Set storage self, address key) internal view returns(bool) {\n        if(self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     @notice fetch a key by row (enumerate).\n     @param self storage pointer to a Set.\n     @param index row to enumerate. Must be < count() - 1.\n     */      \n    function keyAtIndex(Set storage self, uint index) internal view returns(address) {\n        return self.keyList[index];\n    }\n}"
    },
    "contracts/interfaces/ISatellite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\ninterface ISatellite {\n\n    function getPowah(address instance, address user, bytes32 params) external view returns(uint powah);\n    function getSupply(address instance) external view returns(uint supply);\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n   // function() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}"
    },
    "contracts/interperters/xICHIPowah.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStake {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract xICHIPowah {\n    using SafeMath for uint256;\n\n    string public DESCRIPTION = \"ICHIPowah Interperter for xICHI tokens\";\n\n    address public ICHIaddress = 0x903bEF1736CDdf2A537176cf3C64579C3867A881; //mainnet\n\n    function getSupply(address instance) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        ichi = ichiToken.balanceOf(address(stake));\n    }\n\n    function getPowah(address instance, address user, bytes32 /*params*/) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        uint256 xICHI_totalICHI = ichiToken.balanceOf(address(stake));\n        uint256 xICHI_balance = stake.balanceOf(user);\n        uint256 xICHI_total = stake.totalSupply();\n    \n        ichi = xICHI_totalICHI.mul(xICHI_balance).div(xICHI_total);\n    }\n}\n\n"
    },
    "contracts/interperters/sushiPowah.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStake {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IFarm {\n    function getLPSupply(uint256) external view returns (uint256);\n    function userInfo(uint256 poolid, address account) external view returns (uint256, uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n// ichi-ETH (sushi) LP token 0x9cD028B1287803250B1e226F0180EB725428d069\n// sushi farm   0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd\n\ncontract sushiICHIPowah {\n    using SafeMath for uint256;\n\n    string public DESCRIPTION = \"ICHIPowah Interperter for sushi ichi LP tokens\";\n\n    address public ICHIaddress = 0x903bEF1736CDdf2A537176cf3C64579C3867A881; //mainnet\n    address public ICHIFarmAddress = 0x275dFE03bc036257Cd0a713EE819Dbd4529739c8;\n    address public SUSHIFarmAddress = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\n     \n    uint256 public SUSHIFarmPoolID = 79;\n\n    function getSupply(address instance) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        ichi = ichiToken.balanceOf(address(stake));\n    }\n\n    function getPowah(address instance, address user, bytes32 params) public view returns (uint256 ichi) {\n        uint256 poolid = uint256(params);\n        // get user wallet LP balance\n        IStake LPToken = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n        uint256 LP_ICHI_balance = ichiToken.balanceOf(address(LPToken));\n        uint256 user_wallet_total_lp = LPToken.balanceOf(user);\n        ichi = ichi.add(LP_ICHI_balance.mul(user_wallet_total_lp).div(LPToken.totalSupply()));\n\n        // get user balance in farm\n        IFarm ichiFarm = IFarm(ICHIFarmAddress);\n        uint256 user_farm_tokens;\n        (user_farm_tokens, ) = ichiFarm.userInfo(poolid, user);\n        if (user_farm_tokens > 0) {\n           ichi = ichi.add(LP_ICHI_balance.mul(user_farm_tokens).div(LPToken.totalSupply()));\n        }\n\n        // get user balance from sushi farm\n        IFarm sushiFarm = IFarm(SUSHIFarmAddress);\n        uint256 user_sushi_farm_tokens;\n        (user_sushi_farm_tokens, ) = sushiFarm.userInfo(SUSHIFarmPoolID, user);\n        if (user_sushi_farm_tokens > 0) {\n            ichi = ichi.add(LP_ICHI_balance.mul(user_sushi_farm_tokens).div(LPToken.totalSupply()));\n        }\n    }\n}\n\n"
    },
    "contracts/interperters/ichiFarmPowah.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStake {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IFarm {\n    function getLPSupply(uint256) external view returns (uint256);\n    function userInfo(uint256 poolid, address account) external view returns (uint256, uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n\ncontract ICHIFarmPowah {\n    using SafeMath for uint256;\n\n    string public DESCRIPTION = \"ICHIPowah Interperter for ichi LP tokens in ICHI Farm\";\n\n    address public ICHIaddress = 0x903bEF1736CDdf2A537176cf3C64579C3867A881; //mainnet\n    address public ICHIFarmAddress = 0x275dFE03bc036257Cd0a713EE819Dbd4529739c8;\n     \n    uint256 public SUSHIFarmPoolID = 79;\n\n    function getSupply(address instance) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        ichi = ichiToken.balanceOf(address(stake));\n    }\n\n    function getPowah(address instance, address user, bytes32 params) public view returns (uint256 ichi) {\n        uint256 poolid = uint256(params);\n        // get user wallet LP balance\n        IStake LPToken = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n        uint256 LP_ICHI_balance = ichiToken.balanceOf(address(LPToken));\n        uint256 user_wallet_total_lp = LPToken.balanceOf(user);\n        ichi = ichi.add(LP_ICHI_balance.mul(user_wallet_total_lp).div(LPToken.totalSupply()));\n\n        // get user balance in farm\n        IFarm ichiFarm = IFarm(ICHIFarmAddress);\n        uint256 user_farm_tokens;\n        (user_farm_tokens, ) = ichiFarm.userInfo(poolid, user);\n        if (user_farm_tokens > 0) {\n           ichi = ichi.add(LP_ICHI_balance.mul(user_farm_tokens).div(LPToken.totalSupply()));\n        }\n    }\n}\n\n"
    },
    "contracts/interperters/ichiBancorInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStake {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IBancorInsurance {\n    function protectedLiquidity(uint256 id) external view returns \n            (address,\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256);\n    function protectedLiquidityIds(address provider) external view returns (uint256[] memory);\n    function protectedLiquidityCount(address provider) external view returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n\ncontract ICHIBancorInsurance {\n    using SafeMath for uint256;\n\n    string public DESCRIPTION = \"ICHIPowah Interperter for ichi LP tokens in Bancor Insurance\";\n\n    address public ICHIaddress = 0x903bEF1736CDdf2A537176cf3C64579C3867A881; //mainnet\n\n    address public BancorLiquidityProtectionStore = 0xf5FAB5DBD2f3bf675dE4cB76517d4767013cfB55;\n    address public BancorToken = 0x563f6e19197A8567778180F66474E30122FD702A;\n     \n\n    function getSupply(address instance) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        ichi = ichiToken.balanceOf(address(stake));\n    }\n\n    function getPowah(address /*instance*/, address user, bytes32 /*params*/) public view returns (uint256 ichi) {\n        // get amount staked in Bancor Insurance\n        IBancorInsurance bancor = IBancorInsurance(BancorLiquidityProtectionStore);\n        uint256 count = bancor.protectedLiquidityCount(user);\n    \n        if (count > 0) {\n            uint256[] memory ids = bancor.protectedLiquidityIds(user);\n            \n            for(uint256 i=0; i<count; i++) {\n                uint256 id = ids[i];\n                (\n                    ,\n                    address poolToken,\n                    address reserveToken,\n                    ,\n                    uint256 reserveTokenAmount,\n                    ,\n                    ,\n                    \n                ) = bancor.protectedLiquidity(id);\n                if (poolToken == BancorToken && reserveToken == ICHIaddress) {\n                    ichi = ichi.add(reserveTokenAmount);\n                }\n            }\n        }\n    }\n}\n\n"
    },
    "contracts/interperters/1INCHPowah.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IStake {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\n// ichi-1inch LP token 0x1dcE26F543E591c27717e25294AEbbF59AD9f3a5\n// 1inch farm token 0x7dEd1B278D244f707214759C45c1540834890E95\n\ncontract oneINCHICHIPowah {\n    using SafeMath for uint256;\n\n    string public DESCRIPTION = \"ICHIPowah Interperter for 1inch ichi LP tokens\";\n\n    address public ICHIaddress = 0x903bEF1736CDdf2A537176cf3C64579C3867A881; //mainnet\n    address public oneINCHFarmICHIaddress = 0x7dEd1B278D244f707214759C45c1540834890E95;\n\n    function getSupply(address instance) public view returns (uint256 ichi) {\n        IStake stake = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n\n        ichi = ichiToken.balanceOf(address(stake));\n    }\n\n    function getPowah(address instance, address user, bytes32 /*params*/) public view returns (uint256 ichi) {\n        // get user wallet LP balance\n        IStake LPToken = IStake(instance);\n        IERC20 ichiToken = IERC20(ICHIaddress);\n        uint256 LP_ICHI_balance = ichiToken.balanceOf(address(LPToken));\n        uint256 user_wallet_total_lp = LPToken.balanceOf(user);\n        ichi = ichi.add(LP_ICHI_balance.mul(user_wallet_total_lp).div(LPToken.totalSupply()));\n\n        // get user balance in farm\n        IStake LPFarm = IStake(oneINCHFarmICHIaddress);\n        uint256 user_farm_tokens = LPFarm.balanceOf(user);\n        if (user_farm_tokens > 0) {\n            uint256 user_LP_Staked = LPToken.balanceOf(address(LPFarm)).mul(user_farm_tokens).div(LPFarm.totalSupply());\n            ichi = ichi.add(LP_ICHI_balance.mul(user_LP_Staked).div(LPToken.totalSupply()));\n        }\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}